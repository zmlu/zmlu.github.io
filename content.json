{"pages":[{"title":"关于","text":"Hi, I am Jacob. 联系我： Email: zmlu1996@gmail.com","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"[Material Design] 尝试使用 Bottom Navigation","text":"Material Design是由Google推出的全新的设计语言，谷歌表示，这种设计语言旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉”。 Material Design的一些重要功能包括系统字体Roboto的升级版本，同时颜色更鲜艳，动画效果更突出。谷歌的想法是让谷歌平台上的开发者掌握这个新框架，从而让所有应用就有统一的外观，就像是苹果向开发者提出的设计原则一样。 一直感觉Material Design设计很是好看，尤其是底部的导航栏，简约的图标以及透明的背景。决定自己体验一把。 先上效果图： 组件介绍Bottom Navigation经常用于底部导航栏。不过它所包含的标签页不应过多也不应该过少，谷歌官方文档中表示，标签页的个数在3-5个左右合适。 如何实现在Module的build.gradle中添加如下代码1compile 'com.roughike:bottom-bar:2.0.2' 实现Bottom Navigation功能，比较好用的是第三方的BottomBar库，截止2017.1.8，最新的版本是2.0.2，如果需要最新版，请访问 BottomBar的Github Repository 在res下新建类型为xml的xml文件夹 在xml文件夹下新建bottombar_tabs.xml文件res/xml/bottombar_tabs.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;tabs&gt; &lt;tab id=&quot;@+id/tab_one&quot; icon=&quot;@drawable/ic_3d_rotation_white_24dp&quot; title=&quot;财务&quot; barColorWhenSelected=&quot;#865242&quot; inActiveColor=&quot;#FFFFFF&quot; activeColor = &quot;#FFFFFF&quot;/&gt; &lt;tab id=&quot;@+id/tab_two&quot; icon=&quot;@drawable/ic_account_balance_white_24dp&quot; title=&quot;群组&quot; barColorWhenSelected=&quot;#268434&quot; inActiveColor=&quot;#FFFFFF&quot; activeColor = &quot;#FFFFFF&quot;/&gt; &lt;tab id=&quot;@+id/tab_three&quot; icon=&quot;@drawable/ic_accessibility_white_24dp&quot; title=&quot;朋友&quot; barColorWhenSelected=&quot;#8b2099&quot; inActiveColor=&quot;#FFFFFF&quot; activeColor = &quot;#FFFFFF&quot;/&gt; &lt;/tabs&gt;&lt;/PreferenceScreen&gt; barColorWhenSelected属性控制着当这个Tab被选择时，BottomBar的整体颜色。inActiveColor属性是这个Tab未激活时图片的颜色。与之相对应的activeColor属性，则是控制着激活时的图片颜色。 activity_main.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;me.luzhoumin.bottomnavigation.MainActivity&quot;&gt; &lt;com.roughike.bottombar.BottomBar android:id=&quot;@+id/bottomBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_alignParentBottom=&quot;true&quot; app:bb_tabXmlResource=&quot;@xml/bottombar_tabs&quot; app:bb_behavior=&quot;underNavbar&quot; app:bb_inActiveTabAlpha=&quot;0.6&quot; app:bb_activeTabAlpha=&quot;1&quot; app:bb_showShadow=&quot;true&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;36sp&quot; android:text=&quot;Hello World!&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_marginTop=&quot;51dp&quot; /&gt;&lt;/RelativeLayout&gt; app:bb_tabXmlResource指向的是第三步建的xml文件，里面有每个Tab的属性。 MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import android.support.annotation.IdRes;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import com.roughike.bottombar.BottomBar;import com.roughike.bottombar.BottomBarTab;import com.roughike.bottombar.OnTabReselectListener;import com.roughike.bottombar.OnTabSelectListener;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取Bottom Bar组件 BottomBar bottomBar = (BottomBar) findViewById(R.id.bottomBar); //获取用来显示的TextView组件 final TextView tv = (TextView) findViewById(R.id.textview); //设置Bottom Bar的选择监听器 bottomBar.setOnTabSelectListener(new OnTabSelectListener() { @Override public void onTabSelected(@IdRes int tabId) { if (tabId == R.id.tab_one){ tv.setText(&quot;tab_one 被点击&quot;); } if (tabId == R.id.tab_two){ tv.setText(&quot;tab_group 被点击&quot;); } if (tabId == R.id.tab_three){ tv.setText(&quot;tab_three 被点击&quot;); } } }); //设置Bottom Bar的重复选择监听器 bottomBar.setOnTabReselectListener(new OnTabReselectListener() { @Override public void onTabReSelected(@IdRes int tabId) { if (tabId == R.id.tab_one){ tv.setText(&quot;tab_one 再次被点击&quot;); } if (tabId == R.id.tab_two){ tv.setText(&quot;tab_two 再次被点击&quot;); } if (tabId == R.id.tab_three){ tv.setText(&quot;tab_three 再次被点击&quot;); } } }); //设置Tab的Badge BottomBarTab nearby = bottomBar.getTabWithId(R.id.tab_two); nearby.setBadgeCount(5); }} 修改主题样式res/values/styles.xml 1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;!--修改主题为无ActionBar--&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;!--添加--&gt; &lt;item name=&quot;android:navigationBarColor&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; BottomBar APIFor the BottomBar123456789101112131415&lt;com.roughike.bottombar.BottomBar android:id=&quot;@+id/bottomBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_alignParentBottom=&quot;true&quot; app:bb_tabXmlResource=&quot;@xml/bottombar_tabs_three&quot; app:bb_tabletMode=&quot;true&quot; app:bb_behavior=&quot;shifting|shy|underNavbar&quot; app:bb_inActiveTabAlpha=&quot;0.6&quot; app:bb_activeTabAlpha=&quot;1&quot; app:bb_inActiveTabColor=&quot;#222222&quot; app:bb_activeTabColor=&quot;@color/colorPrimary&quot; app:bb_titleTextAppearance=&quot;@style/MyTextAppearance&quot; app:bb_titleTypeFace=&quot;fonts/MySuperDuperFont.ttf&quot; app:bb_showShadow=&quot;true&quot; /&gt; bb_tabXmlResource the XML Resource id for your tabs, that reside in values/xml/ bb_tabletMode if you want the BottomBar to behave differently for tablets. There’s an example of this in the sample project! bb_behavior shifting: the selected tab is wider than the rest. shy: put the BottomBar inside a CoordinatorLayout and it’ll automatically hide on scroll! underNavbar: draw the BottomBar under the navBar! bb_inActiveTabAlpha the alpha value for inactive tabs, that’s used in the tab icons and titles. bb_activeTabAlpha the alpha value for active tabs, that’s used in the tab icons and titles. bb_inActiveTabColor the color for inactive tabs, that’s used in the tab icons and titles. bb_activeTabColor the color for active tabs, that’s used in the tab icons and titles. bb_badgeBackgroundColor the background color for any Badges in this BottomBar. bb_titleTextAppearance custom textAppearance for the titles bb_titleTypeFace path for your custom font file, such as fonts/MySuperDuperFont.ttf. In that case your font path would look like src/main/assets/fonts/MySuperDuperFont.ttf, but you only need to provide fonts/MySuperDuperFont.ttf, as the asset folder will be auto-filled for you. bb_showShadow controls whether the shadow is shown or hidden, defaults to true. For the tabs12345678&lt;tab id=&quot;@+id/tab_recents&quot; title=&quot;Recents&quot; icon=&quot;@drawable/empty_icon&quot; inActiveColor=&quot;#00FF00&quot; activeColor=&quot;#FF0000&quot; barColorWhenSelected=&quot;#FF0000&quot; badgeBackgroundColor=&quot;#FF0000&quot; /&gt; inActiveColor the color for inactive tabs, that’s used in the tab icons and titles. activeColor the color for active tabs, that’s used in the tab icons and titles. barColorWhenSelected the color that the whole BottomBar should be when selected this tab. badgeBackgroundColor the background color for any Badges in this tab. 需要注意的地方 Tab的图标必须是全透明、纯黑、24dp、Padding = 0dp，而且最好所有分辨密度的图片都要有，否则图标会很大或者很小，影响显示效果。 如果想保持在屏幕最底部，记得在布局xml的&lt;com.roughike.bottombar.BottomBar&gt;标签中添加属性android:layout_alignParentBottom=&quot;true&quot;，并且做好第六步工作。 参考文档 谷歌官方文档 BottomBar的Github Repository 与FloatingActionButton和SnackBar合作的效果","link":"/p/GJ0Q47.html"},{"title":"ES镜像制作并启动","text":"拉取镜像及相关配置拉取镜像1docker pull elasticsearch:6.8.3 启动容器1docker run --name=test_es -d -p 9200:9200 -p 9300:9300 docker.io/elasticsearch:6.8.3 查看容器启动情况1docker ps 如果启动成功则访问1你的ip:9200，可以访问则可以直接启动成功，不成功则进行如下操作 服务器中配置（主机配置）查看启动报错日志（情况1）如果报如下错误1234567[2019-10-27T14:38:59,356][INFO ][o.e.n.Node ] [kniXCrn] starting ...[2019-10-27T14:38:59,712][INFO ][o.e.t.TransportService ] [kniXCrn] publish_address {172.17.0.6:9300}, bound_addresses {[::]:9300}[2019-10-27T14:38:59,754][INFO ][o.e.b.BootstrapChecks ] [kniXCrn] bound or publishing to a non-loopback address, enforcing bootstrap checksERROR: [1] bootstrap checks failed[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144][2019-10-27T14:38:59,827][INFO ][o.e.n.Node ] [kniXCrn] stopping ...[2019-10-27T14:38:59,855][INFO ][o.e.n.Node 出现此错误：ERROR: [1] bootstrap checks failed则修改 /etc/sysctl.conf 配置，修改如下： 打开配置文件 sysctl.conf1vim /etc/sysctl.conf 在配置文件最下面，添加如下配置： 1vm.max_map_count=655360 修改完成后，执行此命令 1sysctl -p 然后，重新启动elasticsearch，即可启动成功； 查看启动报错日志（情况2）如果报如下错误123Java HotSpot(TM) 64-Bit Server VM warning: INFO:os::commit_memory(0x0000000085330000, 2060255232, 0) failed;error=’Cannot allocate memory’ (errno=12) 这是由于elasticsearch:tag 默认分配 jvm 空间太大，内存不足以分配导致。解决方法就是修改jvm空间分配。 查找 jvm.options 文件1find /var/lib/ -name jvm.options 修改查找到的 jvm.options 文件1vim /var/lib/docker/overlay2/1ff5019ead459b4d090b4a72e95e3cc17dc7a8432ce0051e470a3c99ac35c4a6/diff/usr/share/elasticsearch/config/jvm.options 123456789# Xms represents the initial size of total heap space# Xmx represents the maximum size of total heap space-Xms512m-Xmx512m################################################################## Expert settings################################################################ 均改为 512m 保存退出，再次运行创建运行elasticsearch命令，成功启动。 在浏览其中访问如果访问不了，在服务器中访问，测试一下是否启动起来了 1curl localhost:9200","link":"/p/10C2G1E.html"},{"title":"ES文件挂载","text":"文件挂载前准备进入启动的 test_es 容器中，找到配置文件所在位置，进入容器命令如下： 1docker exec -it test_es bash 找到配置文件所在位置：/usr/share/elasticsearch/config 下，可以看的配置文件：elasticsearch.yml 拷贝配置文件到宿主机 /opt/elasticsearch/ 目录下 1docker cp test_es:/usr/share/elasticsearch/config/elasticsearch.yml /opt/elasticsearch/ 停止并且删除原来创建的容器 12docker stop test_es docker rm test_es 修改配置文件修改 /opt/elasticsearch/elasticsearch.yml 配置文件 将 transport.host: 0.0.0.0 前的#去掉后保存文件退出，其作用是允许任何ip地址访问elasticsearch。开发测试阶段可以这么做，生产环境下指定具体的IP在elasticsearch.yml配置文件中添加如下跨域访问，方便下面的可视化连接工具连接。 123456cluster.name: &quot;docker-cluster&quot;network.host: 0.0.0.0#开启跨域访问http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 重新创建容器1docker run -d --name=tensquare_elasticsearch -p 9200:9200 -p 9300:9300 -v /opt/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:6.8.3 系统调优启动后发现启动失败了，这时什么原因呢？这与我们刚才修改的配置有关，因为 elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存 区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以 我们还需要系统调优。 一共需要修改两处 修改 /etc/security/limits.conf添加如下内容 12* soft nofile 65536 * hard nofile 65536 nofile是单个进程允许打开的最大文件个数soft nofile 是软限制hard nofile是硬限制 修改 /etc/sysctl.conf添加如下内容 1vm.max_map_count=655360 限制一个进程可以拥有的VMA(虚拟内存区域)的数量；执行下面命令 修改内核参数马上生效 1sysctl -p 重新启动虚拟机，再次启动容器，发现已经可以启动并远程访问","link":"/p/PW04BF.html"},{"title":"gitignore文件不起作用","text":".gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的。 这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下： 123git rm -r --cached .git add .git commit -m 'update .gitignore'","link":"/p/TSMFKX.html"},{"title":"Git设置代理","text":"git下载克隆github的速度在国内很慢，我们可以通过代理的方式加速 设置代理socks5 12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 http12git config --global https.proxy http://127.0.0.1:1087git config --global https.proxy http://127.0.0.1:1087 查看全局 config1cat ~/.gitconfig 显示如下： 12345[http] postBuffer = 524288000 proxy = socks5://127.0.0.1:1086[https] proxy = socks5://127.0.0.1:1086 停用代理12git config --global --unset http.proxygit config --global --unset https.proxy","link":"/p/35NJX8Y.html"},{"title":"HomeKit初始化","text":"前段时间搬家，需要插排，买了个米家的只能插排，感觉用手机控制很方便。看到苹果有自己的Home App来管理智能家居，想试试米家的智能设备能不能接入苹果的HomeKit。首先需要先搭建一个HomeKit服务器。 安装Node.js和npmNode.js v10.x: 1234567# Using Ubuntucurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_10.x | bash -apt-get install -y nodejs 安装编译组件12sudo apt-get install libavahi-compat-libdnssd-devsudo apt-get install build-essential libtool 安装HomeBridge1sudo npm install -g --unsafe-perm homebridge 添加HomeBridge配置文件进入目录： 1cd ~/.homebridge/ 创建文件： 1vim config.json 添加： 12345678{ &quot;bridge&quot;: { &quot;name&quot;: &quot;Homebridge&quot;, &quot;username&quot;: &quot;CC:22:3D:E3:CE:30&quot;, &quot;port&quot;: 51826, &quot;pin&quot;: &quot;031-45-154&quot; }} 保存并退出： 1wq!","link":"/p/3XS9TP7.html"},{"title":"HomeKit添加米家智能插线板","text":"之前搭建了个HomeKit服务器，还没有接入米家的插线板，现在试试能不能让米家设备接入苹果的HomeKit，用手机的Home软件就能控制米家插线板。 安装homebridge-mi-outlet插件1sudo npm -g install homebridge-mi-outlet 安装miio插件1sudo npm -g install miio 用miio插件发现小米智能插线板1miio discover 可以看到Model info：zhimi.powerstrip.v2就是米家智能插线板，将下放的Address和Token记下来： 12Address：192.168.xxx.xxxToken：21a98556732d471e2764cxxxxxxb1ee1 修改HomeBridge的config.json文件在bridge节点后面添加所需的platforms： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152{ &quot;platforms&quot;: [{ &quot;platform&quot;: &quot;MiOutletPlatform&quot;, &quot;deviceCfgs&quot;: [{ &quot;type&quot;: &quot;MiPlugBase&quot;, &quot;ip&quot;: &quot;xxx.xxx.xxx.xxx&quot;, &quot;token&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;, &quot;outletName&quot;: &quot;米家智能插座基础版&quot;, &quot;outletDisable&quot;: false, &quot;temperatureName&quot;: &quot;米家智能插座基础版温度&quot;, &quot;temperatureDisable&quot;: false, &quot;switchLEDName&quot;: &quot;米家智能插座基础版指示灯开关&quot;, &quot;switchLEDDisable&quot;: false }, { &quot;type&quot;: &quot;MiPlugBaseWithUSB&quot;, &quot;ip&quot;: &quot;xxx.xxx.xxx.xxx&quot;, &quot;token&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;, &quot;outletName&quot;: &quot;米家智能插座USB版&quot;, &quot;outletDisable&quot;: false, &quot;temperatureName&quot;: &quot;米家智能插座USB版温度&quot;, &quot;temperatureDisable&quot;: false, &quot;switchUSBName&quot;: &quot;米家智能插座USB版指示灯开关&quot;, &quot;switchUSBDisable&quot;: false }, { &quot;type&quot;: &quot;MiIntelligencePinboard&quot;, &quot;ip&quot;: &quot;xxx.xxx.xxx.xxx&quot;, &quot;token&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;, &quot;outletName&quot;: &quot;米家智能插线板&quot;, &quot;outletDisable&quot;: false, &quot;temperatureName&quot;: &quot;米家智能插线板温度&quot;, &quot;temperatureDisable&quot;: false, &quot;switchLEDName&quot;: &quot;米家智能插线板指示灯开关&quot;, &quot;switchLEDDisable&quot;: false }, { &quot;type&quot;: &quot;MiQingPinboard&quot;, &quot;ip&quot;: &quot;xxx.xxx.xxx.xxx&quot;, &quot;token&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;, &quot;outletName&quot;: &quot;青米智能插线板五孔位版&quot;, &quot;outletDisable&quot;: false, &quot;temperatureName&quot;: &quot;青米智能插线板五孔位版温度&quot;, &quot;temperatureDisable&quot;: false }, { &quot;type&quot;: &quot;MiQingPinboardWithUSB&quot;, &quot;ip&quot;: &quot;xxx.xxx.xxx.xxx&quot;, &quot;token&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;, &quot;outletName&quot;: &quot;青米智能插线板USB版&quot;, &quot;outletDisable&quot;: false, &quot;temperatureName&quot;: &quot;青米智能插线板USB版温度&quot;, &quot;temperatureDisable&quot;: false }] }]} 其中type代表的硬件： 米家智能插座基础版: MiPlugBase 米家智能插座USB版: MiPlugBaseWithUSB 米家智能插线板: MiIntelligencePinboard 青米智能插线板五孔位版: MiQingPinboard 青米智能插线板USB版: MiQingPinboardWithUSB","link":"/p/141WYMG.html"},{"title":"使用Gulp加速Hexo","text":"使用Gulp工具来压缩Hexo生成的public文件，可以通过压缩css、js、html文件来提升网站的访问速度，不过查了网上的一些方法，按照做发现了许多坑。比如gulp和babel版本问题、gulpfile.js文件编写问题。通过一下午的尝试，总结出了一套可行的安装方法。 安装Gulp到Hexo博客参见文章：安装Gulp 进入hexo博客的根目录（public文件夹所在的目录），安装一些必要的组件。 1npm install --save-dev gulp gulp-babel gulp-clean-css gulp-htmlclean gulp-htmlmin gulp-uglify @babel/core @babel/preset-env @babel/register 新建.babelrc依然在hexo博客根目录下新建.babelrc文件 123{ &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ]} 新建gulpfile.js在hexo博客根目录下新建gulpfile.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536var gulp = require('gulp');var babel = require('gulp-babel');var uglify = require('gulp-uglify');var cleanCSS = require('gulp-clean-css');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');/* * css */gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(cleanCSS()) .pipe(gulp.dest('./public'));});gulp.task('minify-js', function () { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']) .pipe(babel()) .pipe(uglify()) .pipe(gulp.dest('./public'));});gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public'));});gulp.task('default',gulp.parallel('minify-html', 'minify-css', 'minify-js')); 使用执行完hexo g产生编译文件后，再手动执行执行gulp 123456789[15:03:44] Using gulpfile E:\\dev\\hexoBlog\\gulpfile.js[15:03:44] Starting 'default'...[15:03:44] Starting 'minify-html'...[15:03:44] Starting 'minify-css'...[15:03:44] Starting 'minify-js'...[15:03:47] Finished 'minify-css' after 3.52 s[15:03:48] Finished 'minify-html' after 4.62 s[15:03:48] Finished 'minify-js' after 4.62 s[15:03:48] Finished 'default' after 4.63 s","link":"/p/8VNSFG.html"},{"title":"安装Gulp","text":"记录一下安装Gulp的过程，参考官方文档，参考地址见文章末尾。 如果你先前将gulp安装到全局环境中了，请执行npm rm --global gulp将gulp删除再继续以下操作。更多信息请参考Sip。 检查 node、npm 和 npx 是否正确安装1node --version 1npm --version 1npx --version 如果上述工具还没安装，请参考这里。 安装 gulp 命令行工具1npm install --global gulp-cli 创建项目目录并进入12npx mkdirp my-projectcd my-project 在项目目录下创建 package.json 文件1npm init 上述命令将指引你设置项目名、版本、描述信息等。 安装 gulp，作为开发时依赖项1npm install --save-dev gulp 检查 gulp 版本1gulp --version 确保输出与下面的屏幕截图匹配，否则你可能需要执行本指南中的上述步骤。 创建 gulpfile 文件利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件，并在文件中输入以下内容： 123456function defaultTask(cb) { // place code for your default task here cb();}exports.default = defaultTask 测试在项目根目录下执行 gulp 命令： 1gulp 如需运行多个任务（task），可以执行gulp &lt;task&gt; &lt;othertask&gt;。 输出结果默认任务（task）将执行，因为任务为空，因此没有实际动作。 参考： Gulp Quick Start","link":"/p/14JCGNP.html"},{"title":"JSP基本语法记录01","text":"最近项目上需要改老项目，巩固一下JSP方面的语法知识。 JSP注释JSP注释用于注释在程序开发过程中的开发提示，不会输出到浏览器端。JSP注释的语法格式如下： 1&lt;%--JSP注释 --%&gt; 与JSP注释相似的是HTML注释，HTML注释的语法格式如下： 1&lt;!-- HTML注释 --&gt; HTML注释的内容会输出到浏览器端，在浏览器端查看网页源代码可以看到HTML注释的内容，而JSP注释的内容则查看不到。下面是JSP注释和HTML注释的代码示例： 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;JSP注释示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 注释示例 &lt;!-- 增加JSP注释 --&gt; &lt;%--JSP注释 --%&gt; &lt;!-- 增加html注释 --&gt; &lt;!-- html注释 --&gt;&lt;/body&gt;&lt;/html&gt; 通过在浏览器端查看网页源代码可以看到html注释的内容可以看到，而JSP注释的内容则查看不到。如下图所示。 JSP声明JSP声明用于声明变量和方法。JSP声明的语法格式如下： 1&lt;%! JSP声明部分 %&gt; 下面看一个JSP声明的实例： 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;JSP声明示例&lt;/title&gt;&lt;/head&gt;&lt;%--下面是JSP声明部分 --%&gt;&lt;%! //声明一个整型变量 public int count; //声明一个方法 public String info(){ return &quot;hello&quot;; }%&gt;&lt;body&gt; &lt;% //输出count的值，然后再将count加1 out.println(count++); %&gt; &lt;br/&gt; &lt;% //输出info()方法的返回值 out.println(info()); %&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中测试该页面，可以看到正常输出了count 的值和info()方法的返回值，每次刷新页面，count的值就会加1。页面效果图如下（刷新许多次）： 输出JSP表达式输出JSP表达式的语法格式如下： 1&lt;%=表达式%&gt; 下面是用表达式改写JSP声明的示例的页面代码，使用JSP表达式输出同样能达到上面的效果，代码如下： 12345678910111213141516171819202122232425&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;JSP表达式示例&lt;/title&gt;&lt;/head&gt;&lt;%--下面是JSP声明部分 --%&gt;&lt;%! //声明一个整型变量 public int count; //声明一个方法 public String info(){ return &quot;hello&quot;; }%&gt;&lt;body&gt; &lt;!-- 使用表达式输出变量的值 --&gt; &lt;%=count++%&gt; &lt;br/&gt; &lt;!-- 使用表达式输出方法的返回值 --&gt; &lt;%=info()%&gt;&lt;/body&gt;&lt;/html&gt; 页面效果如下： JSP脚本JSP脚本是使用Java代码执行页面的控制，JSP脚本的语法格式如下： 1&lt;% 脚本语言代码 %&gt; 下面是一个使用Java脚本语言控制HTML中表格的示例： 1234567891011121314151617181920212223&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;脚本测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1px&quot; cellspacing=&quot;0px&quot; style=&quot;border-collapse:collapse&quot; width=&quot;300px&quot;&gt; &lt;!-- Java脚本 --&gt; &lt;%for (int i=0;i&lt;10;i++) { %&gt; &lt;!-- 上面的循环控制&lt;tr&gt;标签循环 --&gt; &lt;tr&gt; &lt;td&gt;循环值：&lt;/td&gt; &lt;td&gt;&lt;%=i %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%} %&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 页面的效果如下图所示： 上面就是JSP的四种基本语法，详细理解 这四种语法还需要有Servlet的知识，如JSP声明变量和方法，JSP声明的变量和方法会在该JSP页面对应的Servlet中有对应的声明，不是独立存在的，因为在Java中方法是不能独立存在的，方法的声明需要在类中声明。","link":"/p/3AB4DA.html"},{"title":"「翻译」Java 14带来了许多新功能","text":"Java 14包含比前两个发行版更多的新功能-其中大多数旨在简化编程开发工作。 Java 14计划于3月17日发布。版本14包含的JEP（Java Enhancement Proposals）比Java 12和13的总和还多。 那么，对于每天编写和维护代码的Java开发人员来说，最重要的是什么呢？ 在本文中，我研究了以下主要方面： 改进的switch表达式，该表达式最初在Java 12和Java 13中作为预览出现，现在已完全成为Java 14的一部分 新增instanceof的模式匹配（语法糖） 增强的NullPointerExceptions提示（JVM功能） 如果您阅读本文并尝试在代码库中使用其中的某些功能，建议您通过向Java团队提供反馈来分享您的经验。 这样，您就有机会为Java的发展做出贡献。 switch 表达式在Java 14中，switch 表达式被保留变为正式版本。 在早期版本中，switch 表达式是Beta功能。 提醒一下，将特征指定为 Beta 以收集反馈，并且根据反馈可能会更改甚至删除这些特征。 但预计大多数最终将在 Java 中被保留下来。 新的 switch 表达式的优点让出bug的几率降低。 作为一个刷新示例，switch表达式现在可以利用箭头语法，例如在以下示例中： 12345678910var log = switch (event) { case PLAY -&gt; &quot;User has triggered the play button&quot;; case STOP, PAUSE -&gt; &quot;User needs a break&quot;; default -&gt; { String message = event.toString(); LocalDateTime now = LocalDateTime.now(); yield &quot;Unknown event &quot; + message + &quot; logged on &quot; + now; }}; Text Block (Beta)Java 13引入了Text Block作为Beta功能。 Text Block使使用多行字符串文字更加容易。 此功能在Java 14将是第二个版本的Beta功能，并进行了一些调整。 作为回顾，编写带有许多字符串连接和转义序列的代码以提供适当的多行文本格式非常普遍。 下面的代码显示了HTML格式的示例： 12345String html = &quot;&lt;HTML&gt;&quot; +&quot;\\n\\t&quot; + &quot;&lt;BODY&gt;&quot; +&quot;\\n\\t\\t&quot; + &quot;&lt;H1&gt;\\&quot;Java 14 is here!\\&quot;&lt;/H1&gt;&quot; +&quot;\\n\\t&quot; + &quot;&lt;/BODY&gt;&quot; +&quot;\\n&quot; + &quot;&lt;/HTML&gt;&quot;; 使用Text Block，您可以简化此过程并使用界定Text Block开头和结尾的三个引号来编写更优雅的代码： 123456String html = &quot;&quot;&quot;&lt;HTML&gt; &lt;BODY&gt; &lt;H1&gt;&quot;Java 14 is here!&quot;&lt;/H1&gt; &lt;/BODY&gt;&lt;/HTML&gt;&quot;&quot;&quot;; 与普通字符串文字相比，Text Block还提供了更高的表达能力。 Java 14中添加了两个新的转义序列。首先，您可以使用新的\\s转义序列表示单个空格。 其次，您可以使用反斜杠\\来禁止在行尾插入新行字符。 当您想分隔很长的行以简化Text Block内的可读性时，这很有用。 例如，当前处理多行字符串的方法是： 1234String literal = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing &quot; + &quot;elit, sed do eiusmod tempor incididunt ut labore &quot; + &quot;et dolore magna aliqua.&quot;; 使用Text Block中的\\转义序列，可以表示如下： 12345String text = &quot;&quot;&quot; Lorem ipsum dolor sit amet, consectetur adipiscing \\ elit, sed do eiusmod tempor incididunt ut labore \\ et dolore magna aliqua.\\ &quot;&quot;&quot;; instanceof 的模式匹配 (Beta)Java 14引入了该Beta功能，该功能有助于消除对在有条件的instanceof检查之前进行显式强制转换的需求。 例如，考虑以下代码： 123456if (obj instanceof Group) { Group group = (Group) obj; // use group specific methods var entries = group.getEntries();} 可以使用instanceof的模式匹配功能将其重构为： 123if (obj instanceof Group group) { var entries = group.getEntries();} 由于条件检查断言obj是Group类型，为什么还要在第一个代码段中把obj强制转换为Group类型？ 这可能会增加错误几率。` 较短的语法将删除典型Java程序中的许多强制转换。 （2011年一项提出相关语言功能的研究报告指出，所有演员表中约有24％遵循条件语句中的instanceof。） JEP 305涵盖了此更改，并从Joshua Bloch的Effective Java书中指出了一个示例，该示例通过以下相等方法进行说明： 1234@Override public boolean equals(Object o) { return (o instanceof CaseInsensitiveString) &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s); } 通过删除对CaseInsensitiveString的冗余显式转换，可以将前面的代码简化为以下形式： 1234@Override public boolean equals(Object o) { return (o instanceof CaseInsensitiveString cis) &amp;&amp; cis.s.equalsIgnoreCase(s); } 这是一个有趣的预览功能，因为它为更广泛的模式匹配打开了大门。 模式匹配的思想是为语言功能提供方便的语法，以根据某些条件提取对象的成分。 instanceof运算符就是这种情况，因为条件是类型检查，并且提取操作正在调用适当的方法或访问特定字段。 换句话说，此预览功能仅仅是个开始，您可以期待一种语言功能，它可以帮助进一步减少冗长性，从而减少错误的可能性。 record 修饰符 (Beta)本次更新中还有另一种Beta功能：record修饰符。 像到目前为止提出的其他想法一样，此功能遵循减少Java冗长并帮助开发人员编写更简洁的代码的趋势。 记录集中在某些域类上，这些类仅用于将数据存储在字段中，并且不声明任何自定义行为。 为了直接解决问题，用一个简单的类BankTransaction进行举例，该类使用三个字段对交易进行建模：date，amount和description。 声明类时，您需要担心多个问题： 构造方法 Getter 方法 toString() 方法 hashCode() 和 equals() 方法 此类组件的代码通常由IDE自动生成，并占用大量空间。 这是BankTransaction类的完整生成的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BankTransaction { private final LocalDate date; private final double amount; private final String description; public BankTransaction(final LocalDate date, final double amount, final String description) { this.date = date; this.amount = amount; this.description = description; } public LocalDate date() { return date; } public double amount() { return amount; } public String description() { return description; } @Override public String toString() { return &quot;BankTransaction{&quot; + &quot;date=&quot; + date + &quot;, amount=&quot; + amount + &quot;, description='&quot; + description + '\\'' + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; BankTransaction that = (BankTransaction) o; return Double.compare(that.amount, amount) == 0 &amp;&amp; date.equals(that.date) &amp;&amp; description.equals(that.description); } @Override public int hashCode() { return Objects.hash(date, amount, description); }} Java 14提供了一种消除冗长且明确意图的方法，即您所需要的只是一个仅将数据与equals，hashCode和toString方法的实现一起聚合的类。 您可以按以下方式重构BankTransaction： 123public record BankTransaction(LocalDate date, double amount, String description) {} 使用record修饰符，您可以“自动”获取除构造函数和获取器之外的equals，hashCode和toString方法的实现。 要尝试该示例，请记住您需要使用预览标志来编译文件： 1javac --enable-preview --release 14 BankTransaction.java 被record修饰的类是隐式的final类。 这意味着您无法重新分配它们。 请注意，但这并不意味着整个记录都是不变的。 存储在字段中的对象本身可以是可变的。 如果您对有关record的更详细的文章感兴趣，请查看Java杂志上Ben Evans的最新文章。 敬请关注。 从教育的角度来看，record还为下一代Java开发人员提出了有趣的问题。 例如，如果您指导初级开发人员，那么什么时候应该在课程中引入record：在引入OOP和类之前或之后？ 增强的 NullPointerExceptions (Beta)有人说抛出NullPointerExceptions应该是Java中新的“Hello world”，因为您无法逃避它们。 撇开笑话，它们会引起挫败感，因为当代码在生产环境中运行时，它们经常出现在应用程序日志中，这可能使调试变得困难，因为原码不容易获得。 例如，考虑以下代码： 1var name = user.getLocation().getCity().getName(); 在Java 14之前，您可能会收到以下错误： 12Exception in thread &quot;main&quot; java.lang.NullPointerException at NullPointerExample.main(NullPointerExample.java:5) 不幸的是，如果在第5行，有一个具有多个方法调用的赋值——getLocation()和getCity()——两者都可能返回null。 实际上，变量user也可以为null。 因此，尚不清楚是什么导致了NullPointerException。 现在，使用Java 14，有一个新的JVM功能，通过它您可以接收更多信息的诊断： 1Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;Location.getCity()&quot; because the return value of &quot;User.getLocation()&quot; is null 该消息现在具有两个明确的组成部分： 结果：无法调用Location.getCity()。 原因：User.getLocation()的返回值为null。 仅当您使用以下标志运行Java时，增强型诊断才有效： 1-XX:+ShowCodeDetailsInExceptionMessages 这是一个例子： 1java -XX:+ShowCodeDetailsInExceptionMessages NullPointerExample 在Java的未来版本中，此功能可能默认启用，如此处报告。 此增强功能不仅可用于方法调用，还可用于可以导致NullPointerException异常的其他地方，包括字段访问，数组访问和赋值。 总结在Java 14中，有新的Beta功能和更新可帮助开发人员进行日常工作。 例如，Java 14引入了instanceof模式匹配，这是减少显式强制转换的一种方式。 而且，Java 14引入了record，这是一种新的结构，用于简洁地声明仅用于聚合数据的类。 此外，NullPointerException消息已得到改进，具有更好的诊断功能，并且switch表达式现在已成为Java 14的一部分。Text Block是一种可帮助您处理多行字符串值的功能，在引入了两个新的转义序列后，将进行另一轮预览。 Java操作的一部分技术人员可能会感兴趣的另一项更改是JDK Flight Recorder中的事件流。 Ben Evans在他的文章中中讨论了该功能。 如您所见，Java 14带来了很多创新。 您绝对应该考虑一下，并将有关Beta功能的反馈发送给Java团队。 原文：Java 14 Arrives with a Host of New Features","link":"/p/2305442.html"},{"title":"理解 JavaScript 的 async、await","text":"任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async 和 await 在干什么另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？ async 起什么作用这个问题的关键在于，async 函数是怎么处理它的返回值的！我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么： 123456async function testAsync() { return &quot;hello async&quot;;}const result = testAsync();console.log(result); 看到输出就恍然大悟了——输出的是一个 Promise 对象。 12c:\\var\\test&gt; node --harmony_async_await .Promise { 'hello async' } 所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样 123testAsync().then(v =&gt; { console.log(v); // 输出 hello async}); 现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回Promise.resolve(undefined)。 联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。 那么下一个关键点就在于 await 关键字了。 await 到底在等啥一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行 123456789101112131415function getSomething() { return &quot;something&quot;;}async function testAsync() { return Promise.resolve(&quot;hello async&quot;);}async function test() { const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2);}test(); await 等到了要等的，然后呢await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await 帮我们干了啥作个简单的比较上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。 现在举例，用 setTimeout 模拟耗时的异步操作，先来看看不用 async/await 会怎么写 123456789function takeLongTime() { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); });}takeLongTime().then(v =&gt; { console.log(&quot;got&quot;, v);}); 如果改用 async/await 呢，会是这样 123456789101112function takeLongTime() { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); });}async function test() { const v = await takeLongTime(); console.log(v);}test(); 眼尖的同学已经发现 takeLongTime() 没有申明为 async。实际上，takeLongTime() 本身就是返回的 Promise 对象，加不加 async 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。 又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？ async/await 的优势在于处理 then 链单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作： 123456789101112131415161718192021222324/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(n + 200), n); });}function step1(n) { console.log(`step1 with ${n}`); return takeLongTime(n);}function step2(n) { console.log(`step2 with ${n}`); return takeLongTime(n);}function step3(n) { console.log(`step3 with ${n}`); return takeLongTime(n);} 现在用 Promise 方式来实现这三个步骤的处理 1234567891011121314151617181920function doIt() { console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; { console.log(`result is ${result}`); console.timeEnd(&quot;doIt&quot;); });}doIt();// c:\\var\\test&gt;node --harmony_async_await .// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms 输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样 1234567891011async function doIt() { console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is ${result}`); console.timeEnd(&quot;doIt&quot;);}doIt(); 结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样 还有更酷的现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。 1234567891011121314function step1(n) { console.log(`step1 with ${n}`); return takeLongTime(n);}function step2(m, n) { console.log(`step2 with ${m} and ${n}`); return takeLongTime(m + n);}function step3(k, m, n) { console.log(`step3 with ${k}, ${m} and ${n}`); return takeLongTime(k + m + n);} 这回先用 async/await 来写： 123456789101112131415161718async function doIt() { console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is ${result}`); console.timeEnd(&quot;doIt&quot;);}doIt();// c:\\var\\test&gt;node --harmony_async_await .// step1 with 300// step2 with 800 = 300 + 500// step3 with 1800 = 300 + 500 + 1000// result is 2000// doIt: 2907.387ms 除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？ 12345678910111213141516171819function doIt() { console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; { return step2(time1, time2) .then(time3 =&gt; [time1, time2, time3]); }) .then(times =&gt; { const [time1, time2, time3] = times; return step3(time1, time2, time3); }) .then(result =&gt; { console.log(`result is ${result}`); console.timeEnd(&quot;doIt&quot;); });}doIt(); 有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！ 参考：理解 JavaScript 的 async/await - 边城","link":"/p/3Q3X94C.html"},{"title":"实现浏览器WebP图片自适应加载","text":"让网站根据浏览器是否支持WebP来自适应加载相应格式的图片，如果在代码中进行判断，那工作量是巨大的，因为要修改代码中每一个图片的引用方式，有没有一种简便高效的方法呢？答案还是有的，那就是修改Nginx的配置。 主要思路如何判断浏览器是否支持WebP格式的图片，除了在前端加载一个1×1像素的WebP图片来获取宽度的方法，还有个方法，那就是查看浏览器发出的请求头中的Accept字段，如果改字段中带着image/webp说明浏览器支持WebP，反之则就是不持支。 不支持WebP的IE的请求头Accept字段： 支持WebP的Firefox的请求头Accept字段： 支持WebP的Chrome的请求头Accept字段： 根据这个，我们可以修改Nginx的配置文件，让以**.jgp、.jpeg和.png结尾的请求**并且请求头Accept字段包含image/webp的请求进行WebP文件的判断，这个判断我们写在Lua文件中。在Lua文件中，先判断该文件对应的WebP文件是否存在，如果存在，则直接重定向到WebP文件，如果不存在，先调用libwebp方法生成WebP文件，再进行重定向。 有了这个思路，我们进行尝试。 修改准备Nginx安装Lua模块略 服务器安装libwebp参考：Nginx+Lua+libwebp实现服务器图片自动转WebP Nginx.conf因为if不能同时判断多个条件，所以我们定义一个变量，用if修改变量值，最后根据该变量的值来判断是否满足所有的条件。 123456789101112131415location /img { set $cwebp_flag 0; if ($uri ~ \\.(png|jpg|jpeg)$) { set $cwebp_flag '${cwebp_flag}1'; } if ($http_accept ~ image/webp) { set $cwebp_flag '${cwebp_flag}1'; } if ($cwebp_flag = 011) { content_by_lua_file lua/imgProcess.lua; } } imgProcess.lua这个文件主要工作是：先判断该文件对应的WebP文件是否存在，如果存在，则直接重定向到WebP文件，如果不存在，先调用libwebp方法生成WebP文件，再进行重定向。 123456789101112131415161718192021222324252627282930313233343536function file_exists(name) local f=io.open(name,&quot;r&quot;); if f~=nil then io.close(f) return true else return false endend local originalFile = ngx.var.request_filename;local newFile = ngx.var.request_filename .. &quot;.webp&quot;;if not file_exists(newFile) then if not file_exists(originalFile) then ngx.exit(404); return; end os.execute(&quot;cwebp -q 75 &quot; .. originalFile .. &quot; -o &quot; .. newFile); if file_exists(newFile) then ngx.header.vary = 'accept, accept-encoding'; ngx.header.x_webp = 'generate'; ngx.header.real_source_url = ngx.var.uri .. &quot;.webp&quot;; ngx.header.content_type = &quot;image/webp&quot;; return ngx.exec(ngx.var.uri .. &quot;.webp&quot;); else ngx.exit(500); return; endelse ngx.header.vary = 'accept, accept-encoding'; ngx.header.x_webp = 'read'; ngx.header.real_source_url = ngx.var.uri .. &quot;.webp&quot;; ngx.header.content_type = &quot;image/webp&quot;; return ngx.exec(ngx.var.uri .. &quot;.webp&quot;);end 测试用不支持WebP的IE和支持WebP的Chrome打开同一张图片的地址，我们发现服务器给他们返回的响应内容是不一样的。 支持WebP的Chrome的相应内容是WebP格式的图片： 而不支持WebP的IE的相应内容就是普通的jpg图片：","link":"/p/3MDAQPQ.html"},{"title":"Composer多线程安装、更新包方法","text":"Composer通过更换国内镜像源之后，发现安装和更新都很快了，但是由于是单线程下载，有时候还是慢的出奇，能不能在安装更新的时候使用多线程来下载依赖呢？ 有一款Composer包可以实现此功能————prestissimo。 Github地址：hirak/prestissimo 全局安装1composer global require hirak/prestissimo 使用composer install/update 任何需要大量安装依赖的情景，都会自动生效。","link":"/p/3PKQ4GE.html"},{"title":"Nginx+Lua+libwebp实现服务器图片自动转WebP","text":"服务器的流量和加载速度一直是优化的重点，既能保证图片的清晰，又能节省流量、提高加载速度才是一个优秀网页需要达到的目标。 Google推出了一种图片格式: WebP (Google官方网址)，比同类图片压缩率更高，相同画质下，文件的体积更小40%。而且主流浏览器的支持率已经达到80% 查看支持率 原图加载截图：（12.61s） WebP加载截图：（4.72s） 可以看出加载Webp会大大提高加载速度 Nginx安装Lua模块略 服务器安装libwebplibwebp是图片转成webp的工具 1yum install libwebp-tools 测试: 1cwebp -q 100 1.jpg -o 1.webp 如果出现以上信息，说明安装成功。 nginx.conf配置： 让.png.webp、.jpg.webp、.gif.webp的请求执行转WebP的lua文件。 123456789101112location /img { expires 365d; autoindex on; autoindex_exact_size on; try_files $uri $uri/ @webp;} location @webp { if ($uri ~ \\.(png|jpg|gif)\\.webp) { content_by_lua_file lua/imgProcess.lua; }} imgProcess.lua1234567891011121314151617181920function file_exists(name) --判断文件是否存在的方法 local f=io.open(name,&quot;r&quot;); if f~=nil then io.close(f) return true else return false end end local newFile = ngx.var.request_filename; local originalFile = newFile:sub(1, #newFile - 5); --请求的webp图片去掉.webp后缀 if not file_exists(originalFile) then ngx.exit(404); return; end os.execute(&quot;cwebp -q 75 &quot; .. originalFile .. &quot; -o &quot; .. newFile); --用libwebp转换图片 if file_exists(newFile) then ngx.exec(ngx.var.uri); --重定向到转换成的webp图片 else ngx.exit(404); --转换失败：404 end 查看效果访问前图片，服务器上没有WebP文件。 当服务器接收到.jpg.webp的请求后，自动生成WebP文件：","link":"/p/2JJ2AE2.html"},{"title":"Python在全局代理下安装包报错","text":"之前配置小飞机的时候，在我的mac上把终端设置了ALL_PROXY属性，让全局代理。不过在使用Python安装模块的时候报错了。 1Python's requests “Missing dependencies for SOCKS support” when using SOCKS5 from Terminal 以下是解决办法: 首先去掉所有代理，和终端的PROXY属性，然后安装pysocks模块 1pip install pysocks 安装完毕后再加上代理或者终端PROXY属性，即可正常安装其他模块。","link":"/p/1E56RCW.html"},{"title":"Composer安装、更新速度慢问题解决","text":"今天想在自己的服务器上安装一个论坛软件，需要用到php的Composer来安装，无奈很慢，贴出自己的解决方法。 通过更换国内镜像源的方式来加快速度，我使用的是阿里的镜像源，还不错，挺快的。 全局配置（推荐）所有项目都会使用该镜像地址： 1composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 取消配置： 1composer config -g --unset repos.packagist 项目配置仅修改当前工程配置，仅当前工程可使用该镜像地址： 1composer config repo.packagist composer https://mirrors.aliyun.com/composer/ 取消配置： 1composer config --unset repos.packagist","link":"/p/2ZHKMM0.html"},{"title":"Python切片","text":"记录下Python五个高级特性，分别是切片、迭代、列表生成式、生成器、迭代器，记录切片学习的笔记。 切片取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下： 1L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] 取前3个元素，应该怎么做？笨办法： 1[L[0], L[1], L[2]] 或者用循环，不过代码都很长，比如： 1234r = []n = 3for i in range(n): r.append(L[i]) 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片： 1L[0:3] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略： 1L[:3] 类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 1L[-2:] 倒数第一个元素的索引是-1。有一个0-99的数列，前10个数，每两个取一个： 12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 所有数，每5个取一个： 12&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 什么都不写，只写[:]就可以原样复制一个list： 12&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99] 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 1234&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG'","link":"/p/253PZX0.html"},{"title":"使用Scrapy抓取百度热点新闻","text":"安装Scrapy1pip install Scrapy 创建项目1scrapy startproject tutorial 编写Item修改items.py文件： 1234567class BaiduNewsItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field() time = scrapy.Field() category = scrapy.Field() 编写爬虫(Spider)在spiders文件夹下新建一个py文件，命名为baidunews.py 1234567891011121314151617181920212223242526import scrapy,refrom tutorial.items import BaiduNewsItemclass DmozSpider(scrapy.Spider): name = &quot;baidunews&quot; allowed_domains = [&quot;baidu.com&quot;] start_urls = [ &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=guoji&quot;, &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=guonei&quot;, &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=mil&quot;, &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=ent&quot;, &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=sports&quot;, &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=tech&quot;, &quot;http://news.baidu.com/widget?id=LatestNews&amp;channel=lady&quot;, ] def parse(self, response): category = {'guoji':u'\\u56fd\\u9645','guonei':u'\\u56fd\\u5185','mil':u'\\u519b\\u4e8b','ent':u'\\u5a31\\u4e50','sports':u'\\u4f53\\u80b2','tech':u'\\u79d1\\u6280','lady':u'\\u5973\\u4eba'} for sel in response.xpath('//div[@id=&quot;latest-news&quot;]/ul/li'): item = BaiduNewsItem() item['title'] = sel.xpath('a/text()')[0].get() item['link'] = sel.xpath('a/@href')[0].get() item['time'] = sel.xpath('span/text()')[0].get() item['category'] = category[&quot;&quot;.join(re.findall('(^|&amp;)channel=([^&amp;]*)(&amp;|$)',response.url)[0][1])] yield item 运行1scrapy crawl baidunews 查看结果1234567891011121314[{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;巴基斯坦新增新冠肺炎确诊病例1748例，累计563..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667639131171773453&quot;, &quot;time&quot;: &quot;13:30&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;面临破产危机！法国警告雷诺：若不“返回”法国将不提..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667635925032421657&quot;, &quot;time&quot;: &quot;12:39&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;印度战机迫降到巴基斯坦，飞行员一句话瞬间就逗笑了在..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667630787025851625&quot;, &quot;time&quot;: &quot;11:18&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;法国地方政府用菠萝丈量社交距离，被批“太幼稚”&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667624101851668641&quot;, &quot;time&quot;: &quot;09:32&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;大疆：正与巴基斯坦洽谈无人机治蝗 初中毕业生5天就..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667620721060133107&quot;, &quot;time&quot;: &quot;08:38&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;离太近！德国警察“把错门”，错把卢森堡当成法国&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667617809556396961&quot;, &quot;time&quot;: &quot;07:51&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;温格：慎重面对外资进入法甲，不能毁了法国的足球文化&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667573388455325969&quot;, &quot;time&quot;: &quot;22:55&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;五角大楼终于松口，巴铁F-16将迎重大利好，该印度..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667581813539045925&quot;, &quot;time&quot;: &quot;22:20&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;致敬！巴基斯坦坠机事故未造成地面人员死亡原因曝光&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667575501812426929&quot;, &quot;time&quot;: &quot;20:39&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;巴基斯坦官方：坠机事故97人遇难 2人幸存&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667574758558193863&quot;, &quot;time&quot;: &quot;20:29&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;巴基斯坦坠机事件2人生还！幸存者：被火海包围 人们..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667565408074998538&quot;, &quot;time&quot;: &quot;17:59&quot;},{&quot;category&quot;: &quot;国际&quot;, &quot;title&quot;: &quot;里昂主席：西班牙患者更多却能复赛，我们法国真是太蠢..&quot;, &quot;link&quot;: &quot;http://baijiahao.baidu.com/s?id=1667563640465920816&quot;, &quot;time&quot;: &quot;17:31&quot;},] 附：中文乱码如果结果中文乱码，则需要在settings.py中添加如下配置： 1FEED_EXPORT_ENCODING = 'utf-8'","link":"/p/QHV65K.html"},{"title":"Orcale日常记录","text":"记录一下有关Orcale数据库的一些用法。 建立用户和Scheme12CREATE TABLESPACE HBSLH_DBSPACE DATAFILE '/home/oracle/app/oradata/orcl/dbspace_hbslh.dbf' SIZE 2000M AUTOEXTEND ON EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;CREATE USER HBS_LH IDENTIFIED BY CWPASS DEFAULT TABLESPACE HBSLH_DBSPACE; SQL回滚123select * from SW_WRW_DQWRPFL as of timestamp to_timestamp('2018-08-21 17:00:00', 'yyyy-mm-dd hh24:mi:ss');alter table SW_WRW_DQWRPFL enable row movement;flashback table SW_WRW_DQWRPFL to timestamp TO_TIMESTAMP('2018-08-21 17:00:00', 'yyyy-mm-dd hh24:mi:ss'); 查询锁与解锁查询锁12345678SELECT *FROM v$lock;--或select object_name, machine, s.sid, s.serial#from v$locked_object l, dba_objects o, v$session swhere l.object_id = o.object_id and l.session_id=s.sid; 解锁‘Session id, serial id’ 1ALTER system kill session '165,4528';","link":"/p/3PN2K8A.html"},{"title":"各种主键生成方法介绍以及生成优缺点对比","text":"一个系统各个表中必须要存在一列来存放唯一主键ID，并且如果这个系统是分布式的，有多个分布数据库还需要保证每个数据库中的id不能重复，这就要求需要唯一ID的特性： 整个系统ID唯一 ID是数字类型，而且是趋势递增的 ID简短，查询效率快 生成ID的方式有多种，大厂肯定用的没这么简单，但是咱们小系统用一下还是绰绰有余的，下面逐一介绍。 UUID这个是最大众的方案，直接用工具类方法生成一个uuid。 优点： 代码实现简单。 本机生成，没有性能问题 因为是全球唯一的ID，所以迁移数据容易 缺点： 每次生成的ID是无序的，无法保证趋势递增 UUID的字符串存储，查询效率慢 存储空间大 ID本事无业务含义，不可读 应用场景： 类似生成token令牌的场景 不适用一些要求有趋势递增的ID场景 MySQL主键自增这个方法也是很普遍用到的，设置简单，利用了mysql的主键自增auto_increment，默认每次ID加1。 优点： 数字化，id递增 查询效率高 具有一定的业务可读 缺点： 存在单点问题，如果mysql挂了，就没法生成iD了 数据库压力大，高并发抗不住 MySQL多实例主键自增 每台的初始值分别为1,2,3…N，步长为N（这个案例步长为4） 优点：解决了单点问题 缺点：一旦把步长定好后，就无法扩容；而且单个数据库的压力大，数据库自身性能无法满足高并发 应用场景：数据不需要扩容的场景 雪花snowflake算法雪花算法生成64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 实现方式Java版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */public class SnowflakeIdWorker { // ==============================Fields=========================================== /** 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long datacenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;worker Id can't be greater than %d or less than 0&quot;, maxWorkerId)); } if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;datacenter Id can't be greater than %d or less than 0&quot;, maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() { long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) { throw new RuntimeException( String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); } //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) { sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 if (sequence == 0) { //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); } } //时间戳改变，毫秒内序列重置 else { sequence = 0L; } //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) // | (datacenterId &lt;&lt; datacenterIdShift) // | (workerId &lt;&lt; workerIdShift) // | sequence; } /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() { return System.currentTimeMillis(); } //==============================Test============================================= /** 测试 */ public static void main(String[] args) { SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0); for (int i = 0; i &lt; 1000; i++) { long id = idWorker.nextId(); System.out.println(Long.toBinaryString(id)); System.out.println(id); } }} 优点： 此方案每秒能够产生409.6万个ID，性能快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点： 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。 Redis生成方案利用redis的incr原子性操作自增，一般算法为：年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增 优点：有序递增，可读性强 缺点：占用带宽，每次要向redis进行请求 参考： 老顾聊技术-你想了解一线大厂的分布式唯一ID生成方案吗？ 永夜微光-Twitter的分布式自增ID算法snowflake (Java版)","link":"/p/34QH0JS.html"},{"title":"在macOS上运用Crontab运行定时任务","text":"在电脑上运行脚本固然好，但是如果能定时运行，那最好了。 通过创建Crontab，可以在macOS上运行定时任务！让我们做一个示例。 假设您要运行一个名为work.sh的脚本，该脚本可以为您完成一些工作——脚本实际上运行了什么不重要。 但是你每天要花费几分钟来运行这个脚本，大大浪费了时间，这完全可以交给定时任务来完成。 第一步：确保脚本正常首先，确保work.sh能正常运行，并且把它放在一个固定的地方，比如，我就放在了~/.script目录下。 第二步：配置定时任务然后，启动终端（Terminal），运行命令： 1crontab -e 会为你用vim打开一个文本，如果你之前没有配置过定时任务，那文本内容应该是空的，只有一个行号”1”。 然后按i进入vim的编辑模式，输入cron表达式和要执行的命令。 1* * * * * command 比如： 10,15,30,45 * * * * cd ~/.scripts &amp;&amp; ./work.sh 第三步：保存、测试最后，按esc退出到vim的命令模式，输入命令wq!保存退出。然后等待定时任务执行，查看结果。 附录：Cron表达式1* * * * * 解释： 123456* - 分钟 (0-59)* - 小时 (0-23)* - 天 (1-31)* - 月 (1-12)* - 星期 (0-6, 0 是星期天)(从左到右边) 可以通过Crontab.guru生成Cron表达式","link":"/p/11CFSV5.html"},{"title":"iOS 14 新功能预料大合集","text":"iOS14还有几天就能与大家在WWDC20(6月22日)上见面了，苹果一直在加利福尼亚的库比蒂诺总部研发该系统，并且适用设备据说与iOS13相同。本文汇总并且根据功能分类了“自古以来”有关iOS14新功能的爆料。 由于供应商内部交易，早期的预览版iOS14系统或许已经被泄漏，有些爆料达人可以从泄漏版本中发现一些新功能，不过也有许多未知的功能没有被发掘出来，好比每次iOS大更新都会在发版日志中写明更新了啥，但是很多小功能的更新改进不会被列出来（大厂就是大厂）。 据说 iOS14 的开发流程有了很大改进，这种改善可以大大减少开发以及测试的错误率，并且允许测试人员单独关闭或者打开系统中的某些功能来进行对某一项功能的细致测试，这就导致了在Beta版本出现的功能可能会在正式版中砍掉，也有可能测试版中没有的功能在正式版中出现，具有有哪些功能还得看正式版的更新。 iOS 14 发布日期根据以往经验来说，苹果一般会在WWDC上发布新系统，WWDC20的时间已经定在6月22日，并且是头一次线上虚拟发布会。随着发布会发布会接着发布开发者预览版和公众预览版，最后在秋季推送正式版，心急的小伙伴可以到时候下载开发者测试版尝试。 主屏幕苹果万年不变的主屏幕难道终于要变了？据爆料，iOS14 的主屏幕会像 Apple Watch 一样，可以变成列表显示，不再仅仅局限于网格排列。列表显示会列出所有安装在iPhone上的应用，并且可以根据首字母排序，用户还可以根据类别和有无未读通知来对应用进行过滤。 iOS14 还可能提供主屏幕小部件选项（类似早年的Windows Phone？），该选项允许小部件可以像主屏幕上的应用程序图标一样自由移动。 目前尚无此功能的详细信息，但在 iOS14 的代码中可以看出，向右滑动时，它与通知中心“今日”部分中可用的小部件有明显不同。 新增的App以及对现有App的调整Fitness App与现有“健身应用”不同（虽然中文翻译和现有的相同），这个 Fitness App 更像是 Seven 或者 Keep，可以在多平台运行，包括iPhone、Apple Watch、Apple TV，用户可以通过App下载健身视频，根据视频来引导锻炼。 用户佩戴 Apple Watch 可以跟踪锻炼程序的进度，将有各种不同的锻炼类型，包括室内跑步，骑自行车，划船，伸展运动，核心训练，力量训练，户外散步，舞蹈和瑜伽。 信息App苹果正在测试iMessage的新功能，并会在 iOS14 上推出。还有研究表明苹果正在开发基于 Catalyst 的信息App，就说明很多功能在手机平板和电脑上通用。 艾特“@”联系人其中一项功能是“@”功能，类似微信和QQ，可以在iMessage中“@”自己的联系人，如果静音了iMessage群聊，自己被“@”时可以收到消息提醒，功能基本和微信一样。 撤回消息另一个功能是“撤回”，还是和微信QQ类似，用户可以发送iMessage消息后选择撤回该消息，撤回后双方均不可见。 “正在输入…”指示器在群聊中会提示哪些用户正在输入，而且会添加“/me”命令，仅限与Mac，具体有什么作用现在还不清楚。这一部分的改进跟 Telegram 功能差不多。 标记为未读用户可以将某个对话标记为未读，没有什么可解释的，大部分聊天App都具有的功能。 手表上的 Activity AppwatchOS 7 会带来儿童模式（儿童也可以带Apple Watch啦？），并且健身应用也有儿童模式，儿童模式的健身应用不会记录消耗卡路里消耗，而是记录运动时间，这是对儿童而言更健康的指标（也是，小孩哪有那么多力气？）。 新的AR应用（扫码）新的AR应用的内部代码是“Gobi”，用户可以用该应用扫描二维码、苹果码之类的码来获取信息，用苹果的原画说是 “get more information about the world around them”，自己细细品。 这种新AR应用还可能被广泛应用到苹果店和星巴克店内，用户举起手机扫描店内的二维码就能查看正在销售的苹果设备信息或者是星巴克点餐，并且与AirTag相结合带来更多便捷的体验。 设置默认应用这种功能Android上早就有了，从iOS 14开始，Apple可能允许 iPhone 和 iPad 用户将第三方邮件，浏览器和音乐应用程序设置为默认设置，而不是Apple自己的应用程序，因此点击链接或电子邮件地址不会打开 Apple 自己的应用。 这项更改还可以让用户在Homepod上用Siri控制第三方音乐软件，目前仅能控制Apple Music。 苹果内部批评说自己的应用比第三方的更有优势，因为自己的应用默认安装，并且打开链接啥的都是跳转自己的应用，这导致不公平竞争，苹果正在致力于改善这种状况。 健康App —— 睡眠监测传言称，下一代Apple Watch的睡眠跟踪功能将与iPhone上的Health应用程序集成，用户可以在其中设置个性化的睡眠目标。 Health应用程序还将提供改善睡眠的建议。（难道可以抛弃AutoSleep了？） 相册App —— 集成“Shot on iPhone”挑战有了这功能，苹果会不定期的举办比赛，并在相册App中开放提交作品的提示入口，想参赛的用户可以直接在相册App上提交参赛作品，获胜者会获得现金奖励（直接存入Apple Cash？）。 SafariiOS14 的Safari浏览器会内置翻译功能，类似Chrome，直接翻译全网页。可以设定哪些网站进行翻译，也可以直接打开全部网站自动翻译。 iPadOS上的Safari浏览器会完全支持Apple Pencil，包括标记、缩放和上下滚动。 Xcode苹果或许正在开发可以在iPadOS上面运行的Xcode软件。（Xcode：开发苹果App的软件） Find My App“查找我的”App会新增一项通知功能，设定某个联系人没有在在预定时间内到达特定地方，会发出报警通知。这样父母可以为孩子上学设定通知，如果孩子没有在截止日期之前到达学校，则会发送警报。（逃课？蓝瘦。） CarPlayiOS 14中的CarPlay可以支持自定义墙纸，在CarPlay界面上显示墙纸。 这些墙纸还将根据一天中的时间在亮和暗模式之间切换。 CarKey在iOS 13.4中就发现了新的“CarKey” API的提示，这意味着iPhone可以用于锁定，解锁和启动具有NFC功能的汽车。 共享功能还将可用于通过“消息”应用程序将密钥分配给朋友和家人。 CarKey可能会成为 iOS14 功能，它将允许 iPhone 所有者使用其设备代替实体的汽车钥匙。 据iOS14中的代码显示，宝马可能会成为第一批合作伙伴之一。 Apple MapsApple Maps会提供更多的商店商场信息，比如某些企业提供的信息，或者某些苹果店的特定天才吧服务，又或者iMax影院的放映信息等等，反正信息会更加完善丰富。 iCloud Keychain在 iOS14 中，无论什么时候你用相同的密码登陆另一个网站，iCloud Keychain 都会进行警告，这将有助于鼓励用户为每次登录选择不同的密码。 iCloud Keychain 或许还支持双重验证2FA，类似 1Password 支持生成双重验证动态码和自动填充。 ClipsApple正在开发一项新功能，该功能使用户可以通过代号为“Clips”的功能与第三方应用程序中的选定内容和体验进行交互，而无需安装这些应用程序。 “Clips”旨在允许用户链接到应用程序的QR码，然后通过屏幕上的浮动卡与该应用程序的内容进行交互。 通过该卡可以从AppStore下载完整的应用程序，或在已安装的应用程序中打开特定的内容。 据说苹果正在 OpenTable, Yelp, DoorDash, YouTube, 和 Sony 的 PS4 Second Screen app 上测试该功能。 Apple PencilPencilKit的一项新功能允许用户在任何可以打字的输入框上使用Apple Pencil手写文字，然后识别填入，类似于中文手写输入法。该功能似乎可与iOS中的任何文本输入字段一起使用，从而使其与消息，便笺，提醒，邮件等兼容。 HomeKit 更新灯光的 Night Shift灯光的 Night Shift 可以根据时间调节灯光的色温，白天的时候会是冷色温，晚上变成暖色温。 相机面部识别全新的 HomeKit 安全视频功能增加了人员识别功能，这也许可使安全摄像机检测到特定人员，从而将家庭中的人员与陌生人区分开。 HomeKit 安全视频已经支持对象识别，例如人，动物和车辆。 其他更新可自定义的语音合成器苹果似乎正在探索让开发人员通过名为VoiceProvider的新框架在iOS上提供自定义语音合成器的方法。语音合成器扩展将与App Store中的应用程序捆绑在一起，然后可用于替换默认语音，该功能可能对于Apple不支持的语言和方言很重要。 第三方壁纸包苹果可能计划在iOS14中引入对第三方墙纸包的支持，这将使开发人员能够为iPhone创建墙纸选项，这些选项可以通过“设置”中的“墙纸”进行安装。 据说苹果正在致力于把墙纸分类，这将使用户能够更好地分类墙纸。 辅助功能更新每次大版本iOS更新少不了辅助功能的更新。爆料出的第一个功能是将为有听力障碍的人检测火灾警报，门铃，门铃等声音。另一个被爆料出的功能是可以让相机检测手势，来对音频进行调节的功能，以改善轻度至中度听力损失者的 AirPods 或 EarPods 的音频调音。 iOS 14 和 iPadOS 14 支持的设备有传言称，iOS 14 支持所有 iOS 13 设备： iPhone 11 Pro iPhone SE (2020) iPhone 11 Pro Max iPhone 11 iPhone XS iPhone XS Max iPhone XR iPhone X iPhone 8 iPhone 8 Plus iPhone 7 iPhone 7 Plus iPhone 6s iPhone 6s Plus iPhone SE (2016) iPod touch (7th generation) 在iPad方面，iPadOS 14 支持大部分 iOS 13 设备，但是iPad mini 4 (发布于2015年9月) 和 iPad Air 2 (发布于2014年10月）不支持。所以iPad方面如果传言正确的话，支持以下设备： 12.9-inch iPad Pro 11-inch iPad Pro 10.5-inch iPad Pro 9.7-inch iPad Pro iPad (7th generation) iPad (6th generation) iPad (5th generation) iPad mini (5th generation) iPad Air (3rd generation) 关注”家有Apple”公众号，获取更多Apple资讯。","link":"/p/2RSHAR.html"},{"title":"[202006期] 有价值 iOS App","text":"AppStore上的游戏和应用程序很多，能找到一款好的软件或者游戏实属不容易，这一期给大家推荐几款实用软件和有意思的游戏。 Tasks 下载地址：https://apps.apple.com/app/tasks-stay-ahead/id1502903102 价格：免费 应用内购买：有 Tasks是一个待办事项应用程序，可让您随时随地创建需要处理的任务。 您可以将生活中的各项待办事项组织成不同的类别，例如“家庭”，“家庭”，“工作”等等，而且还能设置子任务，使得软件可以用于管理项目。Tasks可以根据任务的创建循序或或者任务到期时间进行排序整理，除此之外还有很多功能，例如标签，多用户支持，日期检测，图像支持等等。 Tasks是款免费软件，但要解锁高级功能则需要进行应用内购买。 New on Flix 下载地址：https://apps.apple.com/us/app/new-on-netflix/id1510913159 价格：免费 应用内购买：有 如果您喜欢观看奈飞（Netflix），如果您常常剧荒，不知道看啥，那么这款软件就再适合不过了。它可以帮您寻找Netflix上的新剧集，虽然不是官方软件，但是小巧玲珑，每天展示奈飞上新增的剧集。移除广告需要应用内购买。","link":"/p/2S9K9NA.html"},{"title":"CarKey功能预测及介绍","text":"苹果的 iPhone 和 Apple Watch 设备已经有 NFC 功能一段时间了，在不久的将来，NFC 功能还可以用于解锁汽车，用户可以通过 iPhone 或者 Apple Watch 来锁定、解锁、启动汽车，从而代替传统的物理钥匙。 苹果称这种新功能叫做 “CarKey”，这就是我们今天介绍的主角。 什么是 CarKey ？CarKey 是一种数字协议，可以让配备了NFC功能的 iPhone 和 Apple Watch 解锁、锁定、启动、控制具有 NFC 功能的汽车。 汽车通常上是不具备 NFC 功能的，就像现在已有的 CarPlay 功能一样，需要汽车制造商来适配这种功能。 汽车制造商可以通过 CarKey 功能，实现 iPhone 对汽车的各种各样控制，但是最基本的控制——包括解锁、锁定、启动汽车是必须有的，这让 CarKey 可以代替物理钥匙。 CarKey 工作原理基于汽车联机联盟（CCC）发布的基于 NFC 的 Digital Key 2.0 规范，苹果正是该联盟中的一员。 Digital Key 2.0 规范使得移动设备可以通过 NFC 与交通设备建立安全稳健的链接。 CarKey 如何工作？现如今，很多汽车都配备了可以近距离感应解锁汽车的卡片或者钥匙扣，就像特斯拉的钥匙是一张卡片，贴近车门框就能解锁。CarKey就跟这种卡片或者钥匙扣很相似，只不过CarKey是通过 NFC 功能实现的，并且可以将“钥匙”保存在 iPhone 上的“钱包”应用中。 用 CarKey 解锁（或锁定）车辆需要将‌ Apple Watch ‌或 ‌iPhone 靠近汽车的 NFC 感应区。 当 NFC 感应区检测到存储在 iPhone 或 Apple Watch 中的 CarKey 时，汽车中的解锁程序将启动，汽车被解锁。 使用“钱包”中的 CarKey 需要进行面容ID或者指纹解锁，但是苹果也推出一种快捷的方式，类似于快捷交通卡一样，不需要任何解锁即可使用该数字钥匙，从 iOS13 的代码中，苹果有这样一段描述：“要使用 CarKey，请将‌ iPhone‌ 或 ‌Apple Watch‌ 靠近感应区。它会自动运行，不需要面容ID。 您可以在电子钱包中更改快速模式设置。” CarKey 如何设置？‌iOS13 中的代码包含有关 CarKey 设置方式的详细信息。CarKey 用户需要将 iPhone 放在位于车内的 NFC 感应区上，配对过程可能需要几分钟即可完成。 配对过程需要输入汽车制造商提供的配对密钥，有些汽车制造商的配对过程还可能需要下载相应的软件，在iOS中找到了以下描述： 将此 iPhone 顶部靠近汽车的NFC感应区，配对过程可能需要几分钟，在配对成功之前，请不要移走 iPhone。请输入汽车制造商提供的CarKey密钥，或者下载 $$汽车制造商$$ 的App进行连接。 CarKey在“钱包”应用中是什么样？CarKey在“钱包”中将会是一张卡片，就像交通卡，当你点击卡片的时候，会展示有关汽车的相关信息。 也会有一个“快捷解锁模式”（无需面容ID和指纹解锁）的选项，或者与别人分享该 CarKey，分享的 CarKey 可以设定较少的权限，比如不能解锁汽车，只能控制车内空调温度。 我能与别人分享 CarKey 吗？答案是肯定的。将会有个选项可以通过“信息”App与别人分享你的 CarKey 数字钥匙，来解锁汽车。这种分享功能很实用，比如去酒店，服务人员代泊车，与亲戚朋友分享汽车，与配偶公用一辆汽车，维修点维修汽车等。 不同的分享权限可以被车主人设定，这就意味着你可以把全部汽车权限分享给别人，也可以分享一部分权限，比如只允许解锁汽车，但是无法启动汽车。分享出去的CarKey有效时间也可以被控制，永久有效或者在某段时间内有效。开发者们从iOS中找到以下描述： $$汽车拥有者$$ 邀请您使用他的 $$汽车品牌$$ 汽车的解锁和驾驶权限。您可以使用您的iPhone 或者 Apple Watch 来解锁、锁定、启动、控制汽车。 CarKey分享具有三种不同等级的权限：解锁汽车、解锁并启动汽车、解锁后备箱。 在“信息”App中可以分享 CarKey 钥匙，就像给对方发送 Apple Cash（国内无此功能） 一样方便，而且，CarKey 只能在私聊中分享，在群聊中是不能分享的。 拥有你汽车 CarKey 密钥的人可以用他们自己的 iPhone 或者 Apple Watch 解锁你的汽车，就像你解锁你自己汽车一样方便。 CarKey 可以在所有汽车上用吗？答案是不会。CarKey 只会在具有NFC功能、并且汽车制造商适配了该功能的汽车上使用。 苹果公司正在与汽车制造商合作，而CarKey可能是工厂安装的选件，仅限于新车型。 但是，与“ CarPlay”一样，这种功能可能会是汽车高级版本的选配选项，某一种型号的低配版本可能不会配备。 iOS 中的屏幕截图表明，苹果公司的首批合作伙伴之一将是宝马。 宝马已经支持在 BMW Connected 应用程序中使用 BMW Digital Key 锁定和解锁车辆并启动发动机，并计划将其引入其他平台，比如苹果的 CarKey。 iPhone 没电时 CarKey 会工作吗？会。CarKey 基于 NFC，即使 ‌iPhone ‌或 ‌Apple Watch‌ 电池电量过低自动关机，它仍将继续运行。 然而，并非总是可以用没电关机了的 iPhone 来开锁汽车，就像快捷公交卡一样，没电的 iPhone 仍可以刷4次，CarKey 能刷几次还不得而知。 苹果会有我使用CarKey的记录吗？不会。Apple 在 iOS13.5.1 中发布了 CarKey 隐私策略。 在设置过程中，为了防止欺诈，将必须输入的一次性兑换令牌与设置时的用户Apple帐户、设备和位置信息一起发送，以将车辆与“钱包”应用程序配对。 唯一的设备标识符将发送给车辆制造商以设置 CarKey。 出于隐私保护目的，标识符对于每个制造商都是唯一的。 苹果公司表示，汽车制造商可以根据制造商的隐私权政策，将设备标识符与有关您的其他信息联系起来。 虽然苹果不保留有关车辆使用情况的信息，但是车辆制造商根据协议了解你的使用记录。这就像使用信用卡，银行怎么会不知道使用记录呢？ CarKey 什么时候可以使用？CarKey 何时可用尚无消息。但是在 iOS 13 多个版本中都发现了 CarKey 的更新迹象，因此绝对是Apple积极开发和完善的东西。 由于 iOS14 将于6月进行内测并于秋季推出，因此 CarKey 很有可能被设计为‌ iOS14 ‌功能，Apple 很有可能在 WWDC 上推出该功能。不过，CarKey 依赖于汽车制造商，因此苹果可能需要等汽车制造商适配完成再推出。 CarKey 未来怎样？Digital Key 2.0 协议虽然在今年5月刚刚发布，汽车联机联盟（CCC）已经在研究 Digital Key 3.0 协议了，3.0协议将会基于蓝牙LE和超宽带感知，iPhone 11, iPhone 11 Pro, 和 iPhone 11 Pro 支持该超宽带感知功能。该 3.0 规范将允许被动的，位置感知的无钥匙访问，也就是说你靠近汽车，汽车就解锁了。 关注”家有Apple”公众号，获取更多Apple资讯。","link":"/p/T5A9FS.html"},{"title":"Element输入框自动去除空格及校验","text":"有的时候需要用输入框输入数据，但是需要数据去除前后空格 可以自定义一个指令，代码如下 12345678910111213141516171819202122232425import Vue from 'vue'Vue.directive('trim', { bind(el, binding, vnode) { setTimeout(() =&gt; { let validateField = '' const formItem = vnode.elm.parentNode.parentNode.__vue__ if (formItem) { validateField = formItem.$options.propsData.prop } const form = vnode.elm.parentNode.parentNode.parentNode.__vue__ const trimStr = function(e) { const value = e.target.value if (value) { e.target.value = value.trim() e.target.dispatchEvent(new CustomEvent('input')) if (form &amp;&amp; validateField) { form.validateField(validateField) } } } vnode.elm.__vue__.$refs.input.addEventListener('blur', trimStr) }) }}) 使用的时候只需要在el-input标签上添加v-trim属性即可。 效果是在input失去焦点的时候，自动把输入的值前后空格去掉，如果输入框有校验，则去掉后触发校验。","link":"/p/2KGC076.html"},{"title":"运用Live Template加快写代码速度","text":"用IDEA写代码的时候往往会重复性的写一段类似或者一样的代码，让人懊恼不已。IDEA自带了个Live Template功能，不仅有许多自带的快捷写代码的功能，而且还可以自定义属于自己的Live Template。 自定义命令可以自定义一些命令。打开IDEA的设置，找到Live Template，右侧添加，可以先添加一个自己的分组，比如我添加了一个My Live的分组，再添加具体的配置 变量用$$包裹，IDEA就知道这是个变量了，变量可以在右下角的Edit variables中赋值 其中，Expression列可以为变量设置一个计算方法，比如className()说明CLASS变量为当前类名，也可以在Default value上指定一个默认值。最后一列如果勾选的话，使用的时候如果这个变量计算出值了则不提示用户进行输入赋值。 以下是我自己使用的一些例子 logger定义Template text 1private static final Logger logger = LoggerFactory.getLogger($CLASS$.class); Variables Name Expression Default value Skip if defined CLASS className() ☑️ 效果 返回ModelAndViewTemplate text 123456@RequestMapping(&quot;/$NAME$.html&quot;)public ModelAndView $NAME$(HttpServletRequest request, HttpServletResponse response) { logger.info(&quot;****************$CLASS$:$NAME$ 开始****************&quot;); logger.info(&quot;****************$CLASS$:$NAME$ 结束****************&quot;); return new ModelAndView(&quot;$NAME$/$NAME$&quot;);} Variables Name Expression Default value Skip if defined NAME CLASS className() ☑️ 效果 返回ModelAndView(有url参数)Template text 123456@RequestMapping(&quot;/$NAME$/{$PATHVARIABLE$}.html&quot;)public ModelAndView $NAME$(@PathVariable(&quot;$PATHVARIABLE$&quot;) String $PATHVARIABLE$, HttpServletRequest request, HttpServletResponse response) { logger.info(&quot;****************$CLASS$:$NAME$ 开始****************&quot;); logger.info(&quot;****************$CLASS$:$NAME$ 结束****************&quot;); return new ModelAndView(&quot;$NAME$/$NAME$&quot;);} Variables Name Expression Default value Skip if defined NAME PATHVARIABLE CLASS className() ☑️ 效果 新建ControllerTemplate text 1234567891011121314@RestControllerpublic class $ControllerName$Controller { private static final Logger logger = LoggerFactory.getLogger($ControllerName$Controller.class); /** * $viewName$ */ @RequestMapping(&quot;/$viewName$.html&quot;) public ModelAndView $viewName$(HttpServletRequest request, HttpServletResponse response) { logger.info(&quot;****************$ControllerName$Controller:$viewName$ 开始****************&quot;); logger.info(&quot;****************$ControllerName$Controller:$viewName$ 结束****************&quot;); return new ModelAndView(&quot;$viewName$/$viewName$&quot;); }} Variables Name Expression Default value Skip if defined ControllerName viewName 效果 自带命令也可以使用自带命令来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。 var 声明 null 判空 notnull 判非空 nn 判非空 for 遍历 fori 带索引的遍历 not 取反 if 条件判断 cast 强转 return 返回值","link":"/p/1W7RVXA.html"},{"title":"How to download Wechat on iOS in india","text":"WeChat has been removed from the App Store India, so how can friends in India download WeChat? Open “App Store” on home screen. Click on the avatar in the upper right corner. At this time, the profile page will be displayed, let us slide to the bottom of the page, there is a logout button, click on it. Then, return to the top of the page, enter the account password provided, and click the sign in button. At this time, a security dialog box will pop up, let’s click on the “Other options” below the blue button. In the “Protect your account” alert that pops up, select the second button(Do not upgrade) After the login is complete, click the “Done” button on the top right, and the store will switch to the US store. Search &amp; download and enjoy :-) After the installation is complete, you can switch back to your Apple ID in the App Store ATTENTION! DO NOT log in to the provided account in the settings app, otherwise the device may be locked.","link":"/p/ESP3TJ.html"},{"title":"Netflix各国价格对比(2019)","text":"先上个简介：Netflix是一家美国公司，在美国、加拿大提供互联网随选流媒体播放，定制DVD、蓝光光碟在线出租业务。该公司成立于1997年，总部位于加利福尼亚州洛斯盖图，1999年开始订阅服务。2009年，该公司可提供多达10万部DVD电影，并有1千万的订户。2007年2月25日，Netflix宣布已经售出第10亿份DVD。 最近入了奈飞，感觉视频挺全，但是价格每个国家都不同，虽然价格不同，但是可以看的视频是同样多的。一下是2019年1月抓取的各个国家的价格数据。方便大家选择哪个国家进行开通续费，仅供参考。 目前土耳其和阿根廷的价格是最便宜的，但是奈飞增加了这两个地区的限制，如果首次注册账号选择这两个地区，需要用当地手机号接收验证码。不过可以首先开通个别的国家的套餐，然后取消套餐，等待套餐过期了之后，用这两个国家的ip进行续费，就不用需要接受验证码了。 Name Basic Plan / RMB Standard Plan / RMB Premium Plan / RMB Austria EUR7.99 / 60.03 EUR11.99 / 90.08 EUR15.99 / 120.13 Australia AUD9.99 / 47.28 AUD13.99 / 66.22 AUD17.99 / 85.15 Belarus EUR7.99 / 60.03 EUR11.99 / 90.08 EUR15.99 / 120.13 Belgium EUR7.99 / 60.03 EUR10.99 / 82.56 EUR15.99 / 120.13 Brazil BRL21.90 / 37.5 BRL32.90 / 56.34 BRL45.90 / 78.60 Bulgaria EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Canada CAD9.99 / 49.90 CAD13.99 / 69.98 CAD16.99 / 84.99 Chile CLP4590 / 45.76 CLP5990 / 59.71 CLP7390 / 73.67 Croatia EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Cyprus EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Czech Republic Kč199 / 58.07 Kč259 / 75.57 Kč319 / 93.08 Denmark DKK79 / 79.43 DKK99 / 99.54 DKK129 / 129.70 Finland EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 France EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Germany EUR7.99 / 60.03 EUR11.99 / 90.08 EUR15.99 / 120.13 Greece EUR7.99 / 60.03 EUR11.99 / 90.08 EUR15.99 / 120.13 Hong Kong HKD63 / 54.14 HKD78 / 67.03 HKD93 / 79.92 Hungary Ft2490 / 58.01 Ft3190 / 74.31 FT3990 / 92.95 Iceland EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 India INR500 / 48.14 INR650 / 62.58 INR800 / 77.02 Ireland EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Isle of Man GBP5.99 / 52.06 GBP7.99 / 69.45 GBP9.99 / 86.83 Israel - - - Italy EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Japan JPY800 / 48.25 JPY1200 / 72.38 JPY1800 / 108.57 Lithuania EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Luxembourg EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Malaysia MYR33 / 53.75 MYR42 / 68.41 MYR51 / 83.07 Mexico MXN129 / 45.83 MXN169 / 60.05 MXN229 / 81.37 Moldova EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Netherlands EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 New Zealand NZD11.49 / 51.51 NZD14.99 / 67.20 NZD18.49 / 82.89 Norway NOK89 / 68.96 NOK109 / 84.46 NOK139 / 107.70 Poland EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Portugal EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Romania EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Singapore SGD10.98 / 54.17 SGD13.98 / 68.98 SGD16.98 / 83.78 Slovakia EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 Slovenia EUR7.99 / 60.03 EUR9.99 / 75.05 EUR11.99 / 90.08 South Africa - - - South Korea KRW9500 / 55.17 KRW12000 / 69.68 KRW14500 / 84.20 Spain EUR7.99 / 60.03 EUR10.99 / 82.56 EUR13.99 / 105.10 Sweden SEK89 / 62.96 SEK109 / 77.11 SEK139 / 98.33 Switzerland CHF11.90 / 78.52 CHF16.90 / 111.51 CHF21.90 / 144.50 Taiwan TWD270 / 58.76 TWD330 / 71.82 TWD39084.88 Thailand - - - Turkey BL15.99 / 18.12 BL27.99 / 31.72 BL39.99 / 45.32 United Kingdom GBP5.99 / 52.05 GBP7.99 / 69.43 GBP9.99 / 86.81 United States USD8.99 / 60.50 USD12.99 / 87.42 USD15.99 / 107.61","link":"/p/2ZVKR9E.html"},{"title":"Mac提示安装包已损坏的解决方法","text":"从网上下载的软件安装包，经常提示： xxx已损坏，无法打开。您应该将它移到废纸篓。 现在总结下解决方法。 方法一在系统偏好设置 - 安全与隐私 - 通用标签中选择来自任何来源选项。 方法二如果没有来自任何来源选项，打开终端执行 1sudo spctl --master-disable 方法三如果方法一和方法二都没有效果，在终端中执行 1sudo xattr -r -d com.apple.quarantine /path/to/app 其中 /path/to/app 是app所在的路径，比如XMind ZEN.app就是 1sudo xattr -r -d com.apple.quarantine /Applications/XMind\\ ZEN.app","link":"/p/2H0WSE.html"},{"title":"真正的自律，就是战胜你自己","text":"1 问答平台上有个问题：“你见过最不求上进的人是什么样子”。有个高赞的回答是：为现状焦虑，又没有毅力践行决心改变自己。 三分钟热度，时常憎恶自己不争气，坚持最多的事情就是坚持不下去……本想在有限的生命里体验更多的生活，有的人却只会把同样的日子机械重复很多年。 他们不曾经历过真正的沧桑，却失守了最后一点少年意气；尚未拥有百毒不侵的内心，却提前丧失了热泪盈眶的能力。 不知你是否发现，很多人空有一颗求上进的心，但在实际生活中，却活得敷衍、潦草、不自律。他们一边痛恨自己总是拖延和懒散，一边又纵容自己，贪图片刻的满足和安逸。 其实，人这一辈子就是战胜自己的过程。如果你管住了自己，就可以拥有更多的自由。如果你管不好自己，就只能被现实左右。 2 大概你也曾经历过无数个失败的自律计划。 坚持早起，但第二天实在起不来，就放弃了。坚持读书，但刚读了几页还是忍不住看手机，就放弃了。坚持减肥，刚确立这个信念，但美食一出现又放弃了。 放弃，其实很简单。只要你的思想稍微松动一下，就可以让自己轻松地逃避那些原本你不愿做的事。但想要坚持就太难了，因为你面对的困难和挫折，经受的挑战和诱惑实在太多了。 人与人之间最大的差距就在于自律。优秀的人想要做成一件事，几乎是言出必行，说到即能做到。但很多人虽然也想改变自己，却很难克服自身的惰性。 自律最难的地方，在于它没法一蹴而就。大多数时刻，你需要反复跟自己做斗争，需要对自己下狠手，需要对自己更严苛，不能给自己丝毫的犹豫和退路。 3 人在什么时刻会意识到自律的重要性？ 大概不是在早晨睡到日上三竿时，也不是在深夜吃着炸鸡喝着啤酒时，更不是在一有空闲就盯着手机追剧时，而是当你发现自己的身材越来越胖、生活越来越无聊、人生越来越失去掌控时，才会感受到巨大的压力。 人在什么时刻会意识到自律的好处？ 大概不是在寒冷的冬天逼着自己五点起床时，也不是在感到疲惫依旧锻炼身体时，更不是一个人在书房独自读书写作时，而是当你发现自己的身体越来越好、事业越来越有所成、生活越来越有趣时，为此感到无比欣慰。 于不自律的人而言，轻松是暂时的，痛苦却是长久的。于自律的人来说，过程是痛苦的，结果却是令人满意的。 记得网上有一个问题：“高度自律是一种什么体验”。有个回答是“不再被生活拖曳着前进，而是未来变得可控，一切有条不紊，想要的生活触手可及”。 当你觉得管不住自己，想要偷懒、想要懈怠时，想一想自己理想的生活，大概就不会沉迷于安逸享乐。当你觉得坚持不下去，想要泄气、放弃时，想一想放任的后果，大概就有了自我约束的紧迫感。 4 人人都渴望更出色，但无论做什么都没有捷径，都要做到自律。 成绩比你好的人可能并没有比你更聪明，不过是在一日又一日的枯燥学业中，坚持不断地练题、背书、做笔记。 身体比你好的人可能并不是天生体质好，而是在一天又一天的单调重复中，坚持不断地早睡、早起、多运动。 文采比你好的人可能并不是有特殊的天赋，而是在一年又一年的平淡光阴里坚持不断地读书、沉淀和积累。 许多人之所以觉得自律很难做到，不过是耽于眼前的轻松和安逸，他们抱着及时行乐、得过且过的态度耗费和虚度人生。 曾看过一句话：我相信一万小时定律，但从不相信天上掉馅饼的灵感和坐享其成的成就。做一个自由又自律的人，靠势必实现的决心认真地活着。 自律最大的敌人，不是温暖的被窝、不是好吃的美食、不是好玩的游戏，而是你想要战胜自己的决心、勇气和毅力。","link":"/p/ZAB5E7.html"},{"title":"请记住人生中的“三”","text":"【男人三大责任】让父母骄傲，让自己的妻子幸福，保持高贵的灵魂 【女人三大责任】激励自己的丈夫，让他飞翔照顾好他的家族做气质非凡，独一无二的自己 【父母三大责任】成为孩子的榜样，帮孩子建立强大内在力量和外在习惯，帮孩子实现梦想 三样东西毁掉一个人:怒气、傲气、小气 三样东西永不放弃:童真、理想、希望 三样东西最无常:成功、财富、机遇 三样东西最无价:健康、善良、真情 三样东西成就人:天时、地利、人和 三样东西要珍惜:父母、家庭、健康 三样东西助成功：目标、方法、改进 三样东西交朋友:诚信、热情、互助 三样东西把握好:机会、工作、婚姻 三样东西得快乐:知足常乐、助人为乐、自得其乐","link":"/p/18JYVC6.html"}],"tags":[{"name":"Material Design","slug":"Material-Design","link":"/tags/Material-Design/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"加速","slug":"加速","link":"/tags/%E5%8A%A0%E9%80%9F/"},{"name":"HomeKit","slug":"HomeKit","link":"/tags/HomeKit/"},{"name":"米家","slug":"米家","link":"/tags/%E7%B1%B3%E5%AE%B6/"},{"name":"Gulp","slug":"Gulp","link":"/tags/Gulp/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"WebP","slug":"WebP","link":"/tags/WebP/"},{"name":"Composer","slug":"Composer","link":"/tags/Composer/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Orcale","slug":"Orcale","link":"/tags/Orcale/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"UUID","slug":"UUID","link":"/tags/UUID/"},{"name":"Netflix","slug":"Netflix","link":"/tags/Netflix/"}],"categories":[{"name":"开发","slug":"开发","link":"/categories/%E5%BC%80%E5%8F%91/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"Android","slug":"开发/Android","link":"/categories/%E5%BC%80%E5%8F%91/Android/"},{"name":"Elasticsearch","slug":"开发/Elasticsearch","link":"/categories/%E5%BC%80%E5%8F%91/Elasticsearch/"},{"name":"Git","slug":"开发/Git","link":"/categories/%E5%BC%80%E5%8F%91/Git/"},{"name":"HomeKit","slug":"开发/HomeKit","link":"/categories/%E5%BC%80%E5%8F%91/HomeKit/"},{"name":"Gulp","slug":"开发/Gulp","link":"/categories/%E5%BC%80%E5%8F%91/Gulp/"},{"name":"JSP","slug":"开发/JSP","link":"/categories/%E5%BC%80%E5%8F%91/JSP/"},{"name":"Java","slug":"开发/Java","link":"/categories/%E5%BC%80%E5%8F%91/Java/"},{"name":"Javascript","slug":"开发/Javascript","link":"/categories/%E5%BC%80%E5%8F%91/Javascript/"},{"name":"Nginx","slug":"开发/Nginx","link":"/categories/%E5%BC%80%E5%8F%91/Nginx/"},{"name":"PHP","slug":"开发/PHP","link":"/categories/%E5%BC%80%E5%8F%91/PHP/"},{"name":"Python","slug":"开发/Python","link":"/categories/%E5%BC%80%E5%8F%91/Python/"},{"name":"SQL","slug":"开发/SQL","link":"/categories/%E5%BC%80%E5%8F%91/SQL/"},{"name":"macOS","slug":"开发/macOS","link":"/categories/%E5%BC%80%E5%8F%91/macOS/"},{"name":"Apple","slug":"日常/Apple","link":"/categories/%E6%97%A5%E5%B8%B8/Apple/"},{"name":"Vue","slug":"开发/Vue","link":"/categories/%E5%BC%80%E5%8F%91/Vue/"},{"name":"技巧","slug":"日常/技巧","link":"/categories/%E6%97%A5%E5%B8%B8/%E6%8A%80%E5%B7%A7/"},{"name":"收藏","slug":"日常/收藏","link":"/categories/%E6%97%A5%E5%B8%B8/%E6%94%B6%E8%97%8F/"},{"name":"摘抄","slug":"日常/摘抄","link":"/categories/%E6%97%A5%E5%B8%B8/%E6%91%98%E6%8A%84/"}]}